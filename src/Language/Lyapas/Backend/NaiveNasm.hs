-- | amd64 nasm. Calling convention is C.
-- Written in english so I can copy-paste easier, ha.
--
-- Integer arguments are passed in registers RDI, RSI, RDX, RCX, R8, R9. Complex is a
-- pointer to allocated complex-structure, so it's also passed in a register.
-- Argument registers plus RAX, R10, R11 are volatile and callee is free to
-- change them. Additional parameters are passed on stack, pushed right to left
-- in the order they appear in the function call.
--
-- RAX is volatile and used for tau, similar to how C uses it for return
-- values. This can be used to interoperate with C.
--
-- inout-аргументы сделаны перезаписыванием аргумента. Вызывающая функция
-- должна затем достать аргумент из переданного положения и записать его в
-- локальную переменную.
--
-- Комплексы представлены как указатель на структуру { cap :: Word64, size ::
-- Word64, data :: Vec OpType size } - данные лежат инлайном вслед за
-- метаданными. При переаллокации (увеличении или сужении) метаданные тоже
-- переносятся в новое место, и старый комплекс освобождается.
module Language.Lyapas.Backend.NaiveNasm
    where

import Control.Arrow (right)
import Control.Monad (forM_)
import Control.Monad.Trans.Writer.CPS (Writer, tell, runWriter)
import Data.Map.Strict (Map, (!))
import Data.MonoTraversable (olength)
import Data.Sequences (group, sort)
import Data.Sequences (pack)
import Data.Text (Text)
import Data.Text.Lazy.Builder (Builder, fromText, fromString, toLazyText)

import qualified Data.Map.Strict as Map

import Language.Lyapas.Syntax

-- | Collection of variables in scope, including arguments. Each is only
-- mentioned once. Sorted.
collectVariables :: Function -> [Argument]
collectVariables (Function _ ras was pars) = map head . group . sort $
    ras <> was <> collectParagraph pars
    where
        collectParagraph ps = do
            Paragraph _ paragraph <- ps
            statement <- paragraph
            case statement of
                Compute s -> extractCompute s
                Control s -> extractControl s
        extractCompute = \case
            SetTau o -> extractOperand o
            Unary _ o -> extractOperand o
            SwapVars id1 id2 -> extractIdent id1 <> extractIdent id2
            SwapComplex n o1 o2 -> [ArgComplex n] <> extractOperand o1 <> extractOperand o2
            ComplexNullary _ n -> pure $ ArgComplex n
            ComplexUnary _ n o -> [ArgComplex n] <> extractOperand o
            ComplexSymbols _ n _ -> pure $ ArgComplex n
            FunctionCall _ rs ws -> do
                let r = rs >>= \case
                        Right op -> extractOperand op
                        Left n -> pure $ ArgComplex n
                let w = ws >>= \case
                        Right op -> extractIdent op
                        Left n -> pure $ ArgComplex n
                r <> w
            _ -> []


        extractControl = \case
            GoCondition (Condition op1 _ op2) _ ->
                extractOperand op1 <> extractOperand op2
            GoEnumerateZeros _ id1 id2 ->
                extractIdent id1 <> extractIdent id2
            _ -> []

        extractOperand (MutableOperand i) = extractIdent i
        extractOperand (UnitVector n) = pure $ ArgVar n
        extractOperand _ = []
        extractIdent = \case
            IdentVar x -> pure $ ArgVar x
            IdentComplexElement n x -> [ArgComplex n] <> extractOperand x
            _ -> []

tellnl = tell . fromText . (<> "\n")
tells = tell . fromString . (<> "\n")

runBuilder = toLazyText . snd . runWriter

buildProgram :: Program -> Writer Builder ()
buildProgram (Program funcs) = do
    tellnl ";; Generated by nlyapas"
    tells . unlines . map ((<>) "extern ") $ runtimeSymbols
    tellnl "\n\n"
    mapM_ buildFunction funcs

buildFunction :: Function -> Writer Builder ()
buildFunction func@(Function (FunctionName name) vargs rargs ps) = do
    tellnl $ "global " <> name
    tellnl $ name <> ":"
    -- Выделяем стэкфрейм под переменные
    let vars = Map.fromAscList . enumerate $ collectVariables func
    tellnl "push rbp\npush r12\nmov rbp, rsp"
    tells $ "sub rsp, " <> show (8 * olength vars)
    -- Копируем аргументы в стэкфрейм
    forM_ (enumerate $ vargs <> rargs) $ \(varName, index) ->
        let offset = varFor vars varName
        in case argFor index of
            Left loadOffset -> do
                mov "r10" (offRbp loadOffset)
                mov (offRbp offset) "r10"
            Right reg -> mov (offRbp offset) reg
    --
    forM_ ps $ \(Paragraph (ParagraphName pname) statements) -> do
        tellnl $ ".P" <> pname <> ":"
        mapM_ (buildStatement vars) statements
    -- Копируем inout аргументы обратно
    let startAt = olength vargs
    forM_ (enumerate rargs) $ \(varName, index') ->
        let index = index' + startAt
            offset = varFor vars varName
        in case argFor index of
            Left storeOffset -> do
                mov "r10" (offRbp offset)
                mov (offRbp storeOffset) "r10"
            Right reg -> mov reg (offRbp offset)
    -- Освобождаем стэкфрейм и возвращаемся
    tellnl "mov rsp, rbp\npop r12\npop rbp\nret"
    pure ()

buildStatement :: Map Argument Int -> Statement -> Writer Builder ()
buildStatement vars = \case
    Control (Goto (ParagraphName name)) -> tellnl $ "jmp .P" <> name
    Control (GoNotZero (ParagraphName name)) ->
        tellnl $ "test rax, rax\njnz .P" <> name
    Control (GoZero (ParagraphName name)) ->
        tellnl $ "test rax, rax\njz .P" <> name
    Control (GoCondition (Condition lo c ro) (ParagraphName name)) -> do
        loadOperand vars "r11" lo
        loadOperand vars "r12" ro
        let comp = case c of
                CompEq -> "e"
                CompNE -> "ne"
                CompG  -> "a"
                CompGE -> "ae"
                CompL  -> "b"
                CompLE -> "be"
        tellnl $ "cmp r11, r12\nj" <> comp <> " .P" <> name
    Control (GoEnumerateZeros _ _ _) -> tellnl "; Unimplemented: go enumerate zeroes"
    --
    Compute (SetTau op) -> loadOperand vars "rax" op
    Compute (Nullary (":bit-negate")) -> tellnl "neg rax"
    -- TODO other nullary
    Compute (Unary (":set-null") operand) -> storeOperand vars "0" operand
    Compute (Unary (":set-full") operand) -> storeOperand vars "0xffff_ffff_ffff_ffff" operand
    Compute (Unary (":set-assign") operand) -> storeOperand vars "rax" operand
    --
    Compute (Unary ":disjunction" operand) -> do
        loadOperand vars "r10" operand
        tellnl "or rax, r10"
    Compute (Unary ":conjunction" operand) -> do
        loadOperand vars "r10" operand
        tellnl "and rax, r10"
    Compute (Unary ":xor" operand) -> do
        loadOperand vars "r10" operand
        tellnl "xor rax, r10"
    Compute (Unary (":left-shift") operand) -> do
        loadOperand vars "rcx" operand
        tellnl "shl rax, rcx"
    Compute (Unary (":right-shift") operand) -> do
        loadOperand vars "rcx" operand
        tellnl "shr rax, rcx"
    Compute (Unary ":add" operand) -> do
        loadOperand vars "r10" operand
        tellnl "add rax, r10"
    Compute (Unary ":sub" operand) -> do
        loadOperand vars "r10" operand
        tellnl "sub rax, r10"
    Compute (Unary ":mul" operand) -> do
        loadOperand vars "r10" operand
        tellnl "mul r10"
    Compute (Unary ":div" operand) -> do
        tellnl "xor rdx, rdx"
        loadOperand vars "r10" operand
        tellnl "div r10"
    Compute (Unary ":mod" operand) -> do
        tellnl "xor rdx, rdx"
        loadOperand vars "r10" operand
        tellnl "div r10\nxchg rax, rdx"
    Compute (Unary ":inc" operand) -> do
        loadOperand vars "r10" operand
        tellnl "inc r10"
        storeOperand vars "r10" operand
    Compute (Unary ":dec" operand) -> do
        loadOperand vars "r10" operand
        tellnl "dec r10"
        storeOperand vars "r10" operand
    --
    Compute (ComplexUnary ":complex-create" complex op) -> do
        loadOperand vars "rdi" op
        tellnl "push rax\ncall __nlyapas_rt__alloc_complex"
        storeComplex vars "rax" complex
    --
    Compute (FunctionCall (FunctionName name) rargs wargs) -> do
        let allArgs = rargs <> map (right MutableOperand) wargs
        forM_ (reverse $ enumerate allArgs) $ \(operand, index) ->
            case argFor index of
                -- Сначала аргументы в регистрах
                Right reg -> case operand of
                    Right op -> loadOperand vars reg op
                    Left complex -> loadComplex vars reg complex
                -- Затем на стэке. Список по которому итерируемся был развёрнут
                -- чтобы они клались как раз справа налево
                Left _offset -> do
                    case operand of
                        Right op -> loadOperand vars "r10" op
                        Left complex -> loadComplex vars "r10" complex
                    tellnl "push r10"
        tellnl $ "call " <> name
        -- Возвращаем inout аргументы из параметров
        forM_ (reverse $ enumerate wargs) $ \(ident, index') -> do
            let index = index' + olength rargs
            -- Либо они уже лежат в регистре, либо попаем их в r10
            reg <- case argFor index of
                Right reg -> pure reg
                Left _offset -> tellnl "pop r10" >> pure "r10"
            case ident of
                Right op -> storeIdent vars reg op
                Left complex -> storeComplex vars reg complex
    --
    other -> tellnl $ "; unimplemented: " <> tshow other


loadOperand :: Map Argument Int -> Text -> Operand -> Writer Builder ()
loadOperand vars reg = \case
    Constant x -> mov reg (tshow x)
    OverflowValue -> do
        mov reg "rdx"
    TimeValue ->
        if reg == "rax"
        then tellnl "call __nlyapas_rt__get_time"
        else tellnl $ "push rax\ncall __nlyapas_rt__get_time\nmov " <> reg <> ", rax\npop rax"
    UnitVector var -> do
        loadIdent vars "rcx" (IdentVar var)
        mov reg "1"
        tellnl $ "shl " <> reg <> ", rcx"
    MutableOperand ident -> loadIdent vars reg ident

loadIdent :: Map Argument Int -> Text -> Identifier -> Writer Builder ()
loadIdent vars reg = \case
    IdentVar "X" ->
        if reg == "rax"
        then tellnl "call __nlyapas_rt__rand"
        else tellnl $ "push rax\ncall __nlyapas_rt__rand\nmov " <> reg <> ", rax\npop rax"
    IdentVar var -> mov reg (offRbp $ varFor vars (ArgVar var))
    IdentComplexElement complex operand -> do
        -- since complex element can't be a complex itself, we use hard-coded
        -- value for copmlex register
        loadOperand vars reg operand
        mov "r12" (offRbp $ varFor vars (ArgComplex complex))
        case complex of
            LongComplex _ -> mov reg ("[16 + r12 + " <> reg <> " * 8]")
            ShortComplex _ -> do
                mov "r12b" ("[16 + r12 + " <> reg <> "]")
                mov reg "r12"
    IdentComplexSize complex -> do
        mov reg (offRbp $ anyComplexVar vars complex)
        mov reg ("[8 + " <> reg <> "]")
    IdentComplexCap complex -> do
        mov reg (offRbp $ anyComplexVar vars complex)
        mov reg ("[" <> reg <> "]")

storeOperand :: Map Argument Int -> Text -> Operand -> Writer Builder ()
storeOperand vars reg = \case
    MutableOperand ident -> storeIdent vars reg ident
    _ -> error "Internal error: storing to constant"

storeIdent :: Map Argument Int -> Text -> Identifier -> Writer Builder ()
storeIdent vars reg = \case
    IdentVar "X" ->
        if reg == "rdi"
        then tellnl "call __nlyapas_rt__seed_rand"
        else tellnl $ "mov rdi, " <> reg <> "\ncall __nlyapas_rt__seed_rand"
    IdentVar var -> mov (offRbp $ varFor vars (ArgVar var)) reg
    IdentComplexElement complex operand -> do
        loadOperand vars "r8" operand
        mov "r12" (offRbp $ varFor vars (ArgComplex complex))
        case complex of
            LongComplex _ -> mov "qword [16 + r12 + r8 * 8]" reg
            ShortComplex _ -> do
                mov "rcx" reg
                mov "[16 + r12 + r8]" "cl"
    IdentComplexSize complex -> do
        mov "r12" (offRbp $ anyComplexVar vars complex)
        mov "qword [r12 + 8]" reg
    IdentComplexCap complex -> do
        mov "rdi" (offRbp $ anyComplexVar vars complex)
        mov "rsi" reg
        tellnl "push rax\ncall __nlyapas_rt__realloc_complex"
        mov (offRbp $ anyComplexVar vars complex) "rax"
        tellnl "pop rax"

loadComplex :: Map Argument Int -> Text -> ComplexName -> Writer Builder ()
loadComplex vars reg complex =
    let offset = varFor vars (ArgComplex complex)
    in mov reg (offRbp offset)

storeComplex :: Map Argument Int -> Text -> ComplexName -> Writer Builder ()
storeComplex vars reg complex =
    let offset = varFor vars (ArgComplex complex)
    in mov (offRbp offset) reg

enumerate :: [a] -> [(a, Int)]
enumerate = flip zip [0, 1 ..]

-- Позиция аргумента по индексу. Либо имя регистра, либо отступ вверх от rbp
argFor :: Int -> Either Int Text
argFor 0 = Right "rdi"
argFor 1 = Right "rsi"
argFor 2 = Right "rdx"
argFor 3 = Right "rcx"
argFor 4 = Right "r8"
argFor 5 = Right "r9"
argFor i = Left $ (i - 6) * 8 + 16 -- 16 for rbp and rip

-- Позиция аргумента вниз относительно rbp
varFor :: Map Argument Int -> Argument -> Int
varFor vars name = -8 - 8 * (vars ! name)

anyComplexVar :: Map Argument Int -> ComplexIdentifier -> Int
anyComplexVar vars name = case Map.lookup (ArgComplex $ LongComplex name) vars of
    Just _ -> varFor vars (ArgComplex $ LongComplex name)
    Nothing -> varFor vars (ArgComplex $ ShortComplex name)

offRbp :: Int -> Text
offRbp offset = pack $ "qword [rbp " <> sign <> show (abs offset) <> "]"
    where sign = if offset > 0 then "+ " else "- "

mov :: Text -> Text -> Writer Builder ()
mov l r = tellnl $ "mov " <> l <> ", " <> r

tshow :: Show a => a -> Text
tshow = pack . show

runtimeSymbols :: [String]
runtimeSymbols =
    [ "__nlyapas_rt__get_time"
    , "__nlyapas_rt__rand"
    , "__nlyapas_rt__seed_rand"
    , "__nlyapas_rt__alloc_complex"
    , "__nlyapas_rt__free_complex"
    , "__nlyapas_rt__realloc_complex"
    , "__nlyapas_rt__print_complex"
    ]
