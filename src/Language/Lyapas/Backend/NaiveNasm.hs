{-# LANGUAGE TypeFamilies #-}
-- | amd64 nasm. Calling convention is C.
-- Written in english so I can copy-paste easier, ha.
--
-- Integer arguments are passed in registers RDI, RSI, RDX, RCX, R8, R9. Complex is a
-- pointer to allocated complex-structure, so it's also passed in a register.
-- Argument registers plus RAX, R10, R11 are volatile and callee is free to
-- change them. Additional parameters are passed on stack, pushed right to left
-- in the order they appear in the function call.
--
-- RAX is volatile and used for tau, similar to how C uses it for return
-- values. This can be used to interoperate with C.
--
-- inout-аргументы сделаны перезаписыванием аргумента. Вызывающая функция
-- должна затем достать аргумент из переданного положения и записать его в
-- локальную переменную.
--
-- Комплексы представлены как указатель на структуру { cap :: Word64, size ::
-- Word64, data :: Vec OpType size } - данные лежат инлайном вслед за
-- метаданными. При переаллокации (увеличении или сужении) метаданные тоже
-- переносятся в новое место, и старый комплекс освобождается.
module Language.Lyapas.Backend.NaiveNasm
    where

import Control.Arrow (right)
import Control.Monad (forM_)
import Control.Monad.Trans.Writer.CPS (Writer, tell, runWriter)
import Data.Containers (insertWith)
import Data.Hashable (hash)
import Data.Map.Strict (Map, (!))
import Data.MonoTraversable (olength, ointercalate)
import Data.Sequences (group, sort, unpack, pack, span, unlines)
import Data.Text (Text)
import Data.Text.Lazy.Builder (Builder, fromText, toLazyText)

import qualified Data.Map.Strict as Map
import qualified Data.Text.Lazy as TL

import Language.Lyapas.Syntax
import Prelude hiding (unlines, span)
import GHC.Stack (HasCallStack)
import Data.Text.Encoding (encodeUtf8, decodeUtf8)

-- | Collection of variables in scope, including arguments. Each is only
-- mentioned once. Sorted.
collectVariables :: Function -> [Argument]
collectVariables (Function _ ras was pars) = map head . group . sort $
    ras <> was <> collectParagraph pars
    where
        collectParagraph ps = do
            Paragraph _ paragraph <- ps
            statement <- paragraph
            case statement of
                Compute s -> extractCompute s
                Control s -> extractControl s
        extractCompute = \case
            SetTau o -> extractOperand o
            Unary _ o -> extractOperand o
            SwapVars id1 id2 -> extractIdent id1 <> extractIdent id2
            SwapComplex n o1 o2 -> [ArgComplex n] <> extractOperand o1 <> extractOperand o2
            ComplexNullary _ n -> pure $ ArgComplex n
            ComplexUnary _ n o -> [ArgComplex n] <> extractOperand o
            ComplexSymbols _ n _ -> pure $ ArgComplex n
            FunctionCall _ rs ws -> do
                let r = rs >>= \case
                        Right op -> extractOperand op
                        Left n -> pure $ ArgComplex n
                let w = ws >>= \case
                        Right op -> extractIdent op
                        Left n -> pure $ ArgComplex n
                r <> w
            _ -> []


        extractControl = \case
            GoCondition (Condition op1 _ op2) _ ->
                extractOperand op1 <> extractOperand op2
            GoEnumerateZeros _ id1 id2 ->
                extractIdent id1 <> extractIdent id2
            _ -> []

        extractOperand (MutableOperand i) = extractIdent i
        extractOperand (UnitVector n) = pure $ ArgVar n
        extractOperand _ = []
        extractIdent = \case
            IdentVar x -> pure $ ArgVar x
            IdentComplexElement n x -> [ArgComplex n] <> extractOperand x
            _ -> []

collectStrings :: [Function] -> [StringLiteral]
collectStrings funcs = do
    Function _ _ _ ps <- funcs
    Paragraph _ ss <- ps
    statement <- ss
    case statement of
        Compute (StringLiteralStatement _ s) -> pure s
        Compute (ComplexSymbols _ _ s) -> pure s
        _ -> []

tells :: Text -> Writer Builder ()
tells = tell . fromText . (<> "\n")

runBuilder :: Writer Builder a -> TL.Text
runBuilder = toLazyText . snd . runWriter

buildProgram :: Program -> Writer Builder ()
buildProgram (Program funcs) = do
    tells ";; Generated by nlyapas"
    tells . unlines . map ((<>) "extern ") $ runtimeSymbols
    tells "\nsection .data"
    let strings = enumerateStrings . collectStrings $ funcs
    forM_ (Map.toList strings) $ \(literal, label) ->
        tells $ label <> ": db " <> escapedLiteral literal
    tells "\nsection .text"
    mapM_ (buildFunction strings) funcs

enumerateStrings :: [StringLiteral] -> (Map StringLiteral Text)
enumerateStrings = go Map.empty where
    go !r [] = Map.fromList . concatMap flipKeys . Map.toList $ r
    go !r (s:ss) =
        let r' = insertWith (<>) (abs $ hash s) [s] r
        in go r' ss
    flipKeys (k, vs) = flip map (enumerate vs) $ \(val, index) ->
        (val, "literal_" <> tshow k <> "_" <> tshow index)

buildFunction :: Map StringLiteral Text -> Function -> Writer Builder ()
buildFunction strings func@(Function (FunctionName name) vargs rargs ps) = do
    tells $ "global " <> name
    tells $ name <> ":"
    -- Выделяем стэкфрейм под переменные
    let vars = Map.fromAscList . enumerate $ collectVariables func
    tells "push rbp\npush r12\nmov rbp, rsp"
    tells $ "sub rsp, " <> tshow (8 * olength vars)
    -- Копируем аргументы в стэкфрейм
    forM_ (enumerate $ vargs <> rargs) $ \(varName, index) ->
        let offset = varFor vars varName
        in case argFor index of
            Left loadOffset -> do
                mov "r10" (offRbp loadOffset)
                mov (offRbp offset) "r10"
            Right reg -> mov (offRbp offset) reg
    --
    forM_ ps $ \(Paragraph (ParagraphName pname) statements) -> do
        tells $ ".P" <> pname <> ":"
        mapM_ (buildStatement vars strings) statements
    -- Копируем inout аргументы обратно
    let startAt = olength vargs
    forM_ (enumerate rargs) $ \(varName, index') ->
        let index = index' + startAt
            offset = varFor vars varName
        in case argFor index of
            Left storeOffset -> do
                mov "r10" (offRbp offset)
                mov (offRbp storeOffset) "r10"
            Right reg -> mov reg (offRbp offset)
    -- Освобождаем стэкфрейм и возвращаемся
    tells "mov rsp, rbp\npop r12\npop rbp\nret"
    pure ()

buildStatement :: HasCallStack => Map Argument Int -> Map StringLiteral Text -> Statement -> Writer Builder ()
buildStatement vars strings = \case
    Control (Goto (ParagraphName name)) -> tells $ "jmp .P" <> name
    Control (GoNotZero (ParagraphName name)) ->
        tells $ "test rax, rax\njnz .P" <> name
    Control (GoZero (ParagraphName name)) ->
        tells $ "test rax, rax\njz .P" <> name
    Control (GoCondition (Condition lo c ro) (ParagraphName name)) -> do
        loadOperand vars "r11" lo
        loadOperand vars "r12" ro
        let comp = case c of
                CompEq -> "e"
                CompNE -> "ne"
                CompG  -> "a"
                CompGE -> "ae"
                CompL  -> "b"
                CompLE -> "be"
        tells $ "cmp r11, r12\nj" <> comp <> " .P" <> name
    Control (GoEnumerateZeros (ParagraphName name) ident enumerator) -> do
        tells "push rax"
        loadIdent vars "rdi" ident
        tells . unlines $
            [ "call __nlyapas_rt__count_trailing_zeroes"
            , "mov rcx, rax"
            , "mov rdi, 1"
            , "shl rdi, rcx"
            , "neg rdi"
            , "and rcx, 63" -- so if 64 or more, it will be 0
            ]
        loadIdent vars "r10" ident
        tells "and r10, rdi"
        storeIdent vars "r10" ident
        storeIdent vars "rcx" enumerator
        tells $ "test rcx, rcx\njz .P" <> name
    --
    Compute (SetTau op) -> loadOperand vars "rax" op
    Compute (SwapVars i1 i2) -> do
        -- TODO: this is better done by altering the map, but it's immutable
        loadIdent vars "r10" i1
        loadIdent vars "r11" i2
        storeIdent vars "r11" i1
        storeIdent vars "r10" i2
    Compute (SwapComplex complex op1 op2) -> do
        loadIdent vars "r10" $ IdentComplexElement complex op1
        loadIdent vars "r11" $ IdentComplexElement complex op2
        storeIdent vars "r11" $ IdentComplexElement complex op1
        storeIdent vars "r10" $ IdentComplexElement complex op2
    Compute (Nullary (":bit-negate")) -> tells "neg rax"
    Compute (Nullary (":rightmost-one")) ->
        tells "mov rdi, rax\ncall __nlyapas_rt__count_trailing_zeroes"
    Compute (Unary (":set-null") operand) -> storeOperand vars "0" operand
    Compute (Unary (":set-full") operand) -> storeOperand vars "0xffff_ffff_ffff_ffff" operand
    Compute (Unary (":set-assign") operand) -> storeOperand vars "rax" operand
    --
    Compute (Unary ":disjunction" operand) -> do
        loadOperand vars "r10" operand
        tells "or rax, r10"
    Compute (Unary ":conjunction" operand) -> do
        loadOperand vars "r10" operand
        tells "and rax, r10"
    Compute (Unary ":xor" operand) -> do
        loadOperand vars "r10" operand
        tells "xor rax, r10"
    Compute (Unary (":left-shift") operand) -> do
        loadOperand vars "rcx" operand
        tells "shl rax, rcx"
    Compute (Unary (":right-shift") operand) -> do
        loadOperand vars "rcx" operand
        tells "shr rax, rcx"
    Compute (Unary ":add" operand) -> do
        loadOperand vars "r10" operand
        tells "add rax, r10"
    Compute (Unary ":sub" operand) -> do
        loadOperand vars "r10" operand
        tells "sub rax, r10"
    Compute (Unary ":mul" operand) -> do
        loadOperand vars "r10" operand
        tells "mul r10"
    Compute (Unary ":div" operand) -> do
        tells "xor rdx, rdx"
        loadOperand vars "r10" operand
        tells "div r10"
    Compute (Unary ":mod" operand) -> do
        tells "xor rdx, rdx"
        loadOperand vars "r10" operand
        tells "div r10\nxchg rax, rdx"
    Compute (Unary ":inc" operand) -> do
        loadOperand vars "r10" operand
        tells "inc r10"
        storeOperand vars "r10" operand
    Compute (Unary ":dec" operand) -> do
        loadOperand vars "r10" operand
        tells "dec r10"
        storeOperand vars "r10" operand
    --
    Compute (ComplexUnary ":complex-create" complex op) -> do
        loadOperand vars "rdi" op
        tells "push rax\ncall __nlyapas_rt__alloc_complex"
        storeComplex vars "rax" complex
        tells "pop rax"
    Compute (ComplexNullary ":complex-delete" complex) -> do
        loadComplex vars "rdi" complex
        tells "push rax\ncall __nlyapas_rt__free_complex\npop rax"
    Compute (ComplexNullary ":complex-shrink" _complex) ->
        pure () -- TODO currently even realloc doesn't shrink, so
    Compute (ComplexNullary ":complex-push" complex) -> do
        loadComplex vars "r12" complex
        mov "r11" "[r12 + 8]"
        case complex of
            LongComplex _ -> mov "[16 + r12 + r11*8]" "rax"
            ShortComplex _ -> mov "[16 + r12 + r11]" "al"
        tells "inc qword [r12 + 8]"
    Compute (ComplexNullary ":complex-pop" complex) -> do
        loadComplex vars "r12" complex
        tells "dec qword [r12 + 8]"
        mov "r11" "[r12 + 8]"
        case complex of
            LongComplex _ -> mov "rax" "[16 + r12 + r11*8]"
            ShortComplex _ -> mov "al" "[16 + r12 + r11]"
    Compute (ComplexUnary ":complex-push" complex operand) -> do
        loadOperand vars "r10" operand
        loadComplex vars "r12" complex
        mov "r11" "[r12 + 8]"
        case complex of
            LongComplex _ -> mov "[16 + r12 + r11*8]" "r10"
            ShortComplex _ -> mov "[16 + r12 + r11]" "r10b"
        tells "inc qword [r12 + 8]"
    Compute (ComplexUnary ":complex-pop" complex operand) ->
        case operand of
            Constant 0 -> do
                loadComplex vars "rdi" complex
                tells $ "dec qword [rdi + 8]"
                tells . unlines $
                    [ "lea rcx, [rdi + 8]"
                    , "lea rdi, [rdi + 16]"
                    , case complex of
                        LongComplex _ -> "lea rsi, [rdi + 8]"
                        ShortComplex _ -> "lea rsi, [rdi + 1]"
                    , "rep movsq"
                    ]
            other -> error $ "Incorrect pop operand: " <> show other
    Compute (ComplexNullary ":set-null" complex) -> do
        loadComplex vars "rdi" complex
        mov "rcx" "[r12 + 8]"
        tells "add rdi, 16"
        tells "push rax\nxor rax, rax"
        case complex of
            LongComplex _ -> tells "rep stosq"
            ShortComplex _ -> tells "rep stosb"
        tells "pop rax"
    Compute (ComplexNullary ":complex-print" complex) -> do
        loadComplex vars "rdi" complex
        tells "push rax\ncall __nlyapas_rt__print_complex\npop rax"
    Compute (ComplexNullary ":complex-read" complex) -> do
        loadComplex vars "rdi" complex
        tells "push rax\ncall __nlyapas_rt__read_complex\npop rax"
    --
    Compute (ComplexSymbols ":complex-append" complex string) -> do
        loadComplex vars "rdi" complex
        tells "add rdi, 16"
        mov "rsi" (strings ! string)
        mov "rcx" (literalLength string)
        mov "[rdi - 8]" "rcx"
        tells "rep movsb"
    Compute (StringLiteralStatement ":print-string" string) -> do
        mov "rdi" (strings ! string)
        mov "rsi" (literalLength string)
        tells "push rax\ncall __nlyapas_rt__print_string\npop rax"

    --
    Compute (FunctionCall (FunctionName name) rargs wargs) -> do
        let allArgs = rargs <> map (right MutableOperand) wargs
        forM_ (reverse $ enumerate allArgs) $ \(operand, index) ->
            case argFor index of
                -- Сначала аргументы в регистрах
                Right reg -> case operand of
                    Right op -> loadOperand vars reg op
                    Left complex -> loadComplex vars reg complex
                -- Затем на стэке. Список по которому итерируемся был развёрнут
                -- чтобы они клались как раз справа налево
                Left _offset -> do
                    case operand of
                        Right op -> loadOperand vars "r10" op
                        Left complex -> loadComplex vars "r10" complex
                    tells "push r10"
        tells $ "call " <> name
        -- Возвращаем inout аргументы из параметров
        forM_ (reverse $ enumerate wargs) $ \(ident, index') -> do
            let index = index' + olength rargs
            -- Либо они уже лежат в регистре, либо попаем их в r10
            reg <- case argFor index of
                Right reg -> pure reg
                Left _offset -> tells "pop r10" >> pure "r10"
            case ident of
                Right op -> storeIdent vars reg op
                Left complex -> storeComplex vars reg complex
    --
    other -> tells $ "; unimplemented: " <> tshow other


loadOperand :: Map Argument Int -> Text -> Operand -> Writer Builder ()
loadOperand vars reg = \case
    Constant x -> mov reg (tshow x)
    OverflowValue -> do
        mov reg "rdx"
    TimeValue ->
        if reg == "rax"
        then tells "call __nlyapas_rt__get_time"
        else tells $ "push rax\ncall __nlyapas_rt__get_time\nmov " <> reg <> ", rax\npop rax"
    UnitVector var -> do
        loadIdent vars "rcx" (IdentVar var)
        mov reg "1"
        tells $ "shl " <> reg <> ", rcx"
    MutableOperand ident -> loadIdent vars reg ident

loadIdent :: Map Argument Int -> Text -> Identifier -> Writer Builder ()
loadIdent vars reg = \case
    IdentVar "X" ->
        if reg == "rax"
        then tells "call __nlyapas_rt__rand"
        else tells $ "push rax\ncall __nlyapas_rt__rand\nmov " <> reg <> ", rax\npop rax"
    IdentVar var -> mov reg (offRbp $ varFor vars (ArgVar var))
    IdentComplexElement complex operand -> do
        -- since complex element can't be a complex itself, we use hard-coded
        -- value for copmlex register
        loadOperand vars reg operand
        mov "r12" (offRbp $ varFor vars (ArgComplex complex))
        case complex of
            LongComplex _ -> mov reg ("[16 + r12 + " <> reg <> " * 8]")
            ShortComplex _ -> do
                mov "r12b" ("[16 + r12 + " <> reg <> "]")
                mov reg "r12"
    IdentComplexSize complex -> do
        mov reg (offRbp $ anyComplexVar vars complex)
        mov reg ("[8 + " <> reg <> "]")
    IdentComplexCap complex -> do
        mov reg (offRbp $ anyComplexVar vars complex)
        mov reg ("[" <> reg <> "]")

storeOperand :: HasCallStack => Map Argument Int -> Text -> Operand -> Writer Builder ()
storeOperand vars reg = \case
    MutableOperand ident -> storeIdent vars reg ident
    other -> error $ "Internal error: storing to constant: " <> show other

storeIdent :: Map Argument Int -> Text -> Identifier -> Writer Builder ()
storeIdent vars reg = \case
    IdentVar "X" ->
        if reg == "rdi"
        then tells "call __nlyapas_rt__seed_rand"
        else tells $ "mov rdi, " <> reg <> "\ncall __nlyapas_rt__seed_rand"
    IdentVar var -> mov (offRbp $ varFor vars (ArgVar var)) reg
    IdentComplexElement complex operand -> do
        loadOperand vars "r8" operand
        mov "r12" (offRbp $ varFor vars (ArgComplex complex))
        case complex of
            LongComplex _ -> mov "qword [16 + r12 + r8 * 8]" reg
            ShortComplex _ -> do
                mov "rcx" reg
                mov "[16 + r12 + r8]" "cl"
    IdentComplexSize complex -> do
        mov "r12" (offRbp $ anyComplexVar vars complex)
        mov "qword [r12 + 8]" reg
    IdentComplexCap complex -> do
        mov "rdi" (offRbp $ anyComplexVar vars complex)
        mov "rsi" reg
        tells "push rax\ncall __nlyapas_rt__realloc_complex"
        mov (offRbp $ anyComplexVar vars complex) "rax"
        tells "pop rax"

loadComplex :: Map Argument Int -> Text -> ComplexName -> Writer Builder ()
loadComplex vars reg complex =
    let offset = varFor vars (ArgComplex complex)
    in mov reg (offRbp offset)

storeComplex :: Map Argument Int -> Text -> ComplexName -> Writer Builder ()
storeComplex vars reg complex =
    let offset = varFor vars (ArgComplex complex)
    in mov (offRbp offset) reg

enumerate :: [a] -> [(a, Int)]
enumerate = flip zip [0, 1 ..]

-- Позиция аргумента по индексу. Либо имя регистра, либо отступ вверх от rbp
argFor :: Int -> Either Int Text
argFor 0 = Right "rdi"
argFor 1 = Right "rsi"
argFor 2 = Right "rdx"
argFor 3 = Right "rcx"
argFor 4 = Right "r8"
argFor 5 = Right "r9"
argFor i = Left $ (i - 6) * 8 + 16 -- 16 for rbp and rip

-- Позиция аргумента вниз относительно rbp
varFor :: Map Argument Int -> Argument -> Int
varFor vars name = -8 - 8 * (vars ! name)

anyComplexVar :: Map Argument Int -> ComplexIdentifier -> Int
anyComplexVar vars name = case Map.lookup (ArgComplex $ LongComplex name) vars of
    Just _ -> varFor vars (ArgComplex $ LongComplex name)
    Nothing -> varFor vars (ArgComplex $ ShortComplex name)

offRbp :: Int -> Text
offRbp offset = pack $ "qword [rbp " <> sign <> show (abs offset) <> "]"
    where sign = if offset > 0 then "+ " else "- "

mov :: Text -> Text -> Writer Builder ()
mov l r = tells $ "mov " <> l <> ", " <> r

tshow :: Show a => a -> Text
tshow = pack . show

literalLength :: StringLiteral -> Text
literalLength (StringLiteral s) = tshow . olength $ s

escapedLiteral :: StringLiteral -> Text
escapedLiteral (StringLiteral s) = (ointercalate "," . go . encodeUtf8 $ s) where
    printable c = c >= 32 && c <= 126
    go bs
        | olength bs == 0  = []
        | otherwise =
            let (goods, other) = span printable bs
                (bads, next) = span (not . printable) other
                encodedBads = map tshow . unpack $ bads
            in ["\"" <> decodeUtf8 goods <> "\""] <> encodedBads <> go next

runtimeSymbols :: [Text]
runtimeSymbols =
    [ "__nlyapas_rt__get_time"
    , "__nlyapas_rt__rand"
    , "__nlyapas_rt__seed_rand"
    , "__nlyapas_rt__alloc_complex"
    , "__nlyapas_rt__free_complex"
    , "__nlyapas_rt__realloc_complex"
    , "__nlyapas_rt__print_complex"
    , "__nlyapas_rt__print_string"
    , "__nlyapas_rt__read_complex"
    ]
